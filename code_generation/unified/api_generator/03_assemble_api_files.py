import argparse
import json
import pathlib
import sys
import textwrap


def clean_group_name(group: str) -> str:
    """
    Converts a group name like 'Attribute Commands' or '3D Commands (Visualization)'
    into a valid Python module name like 'attributes' or '3d_visualization'.
    """
    name = group.lower().replace(" commands", "").strip()
    name = "".join(c if c.isalnum() else "_" for c in name)
    name = "_".join(filter(None, name.split("_")))
    return name


class FileAssembler:
    """
    Takes a dictionary of commands with pre-generated method code and assembles
    the final Python package structure for the unified_api.
    """

    def __init__(self, commands_with_code: dict, output_dir: pathlib.Path):
        self._commands = commands_with_code
        self._output_dir = output_dir
        self._class_info = {"tapir": [], "official": []}

    def assemble(self):
        """Runs the entire assembly process."""
        print("--- Assembling Final API Files ---")
        self._create_directories()
        self._assemble_group_files()
        self._assemble_main_api_file()
        print(f"✅ Assembly complete. Final files are in: {self._output_dir}")

    def _create_directories(self):
        """Creates the output directory and the tapir/ and official/ subdirectories."""
        self._output_dir.mkdir(exist_ok=True)
        for source in ["tapir", "official"]:
            source_dir = self._output_dir / source
            source_dir.mkdir(exist_ok=True)
            (source_dir / "__init__.py").touch()
        (self._output_dir / "__init__.py").touch()
        print("  - Created base directory structure.")

    def _assemble_group_files(self):
        """Generates a .py file for each command group with dynamic imports."""
        print("  - Assembling command group files with direct imports...")
        for source, groups in self._commands.items():
            for group_name, commands in groups.items():
                command_deps = set()
                type_deps = set()
                for cmd in commands:
                    command_deps.update(cmd.get("command_model_dependencies", []))
                    type_deps.update(cmd.get("type_model_dependencies", []))

                imports_block = self._create_imports_block(source, command_deps, type_deps)

                clean_name = clean_group_name(group_name)
                class_name = f"{clean_name.replace('_', ' ').title().replace(' ', '')}Commands"
                sorted_commands = sorted(commands, key=lambda c: c["name"])
                method_strings = [cmd["method_code"] for cmd in sorted_commands]

                file_content = self._create_group_class_content(class_name, imports_block, method_strings)

                output_path = self._output_dir / source / f"{clean_name}.py"
                output_path.write_text(file_content, encoding="utf-8")

                self._class_info[source].append({"module": clean_name, "class": class_name})

    def _create_imports_block(self, source: str, command_deps: set, type_deps: set) -> str:
        """Creates the specific 'from ... import ...' lines for a file."""
        lines = []
        if command_deps:
            sorted_deps = ", ".join(sorted(list(command_deps)))
            lines.append(f"from multiconn_archicad.models.{source}.commands import {sorted_deps}")
        if type_deps:
            sorted_deps = ", ".join(sorted(list(type_deps)))
            lines.append(f"from multiconn_archicad.models.{source}.types import {sorted_deps}")
        return "\n".join(lines)

    def _create_group_class_content(self, class_name: str, imports_block: str, methods: list[str]) -> str:
        """Creates the full Python code string for a single group class file."""

        header = textwrap.dedent(f"""
            # This file is automatically generated by the build system.
            # Do not edit this file directly.

            from __future__ import annotations
            from typing import Any, TYPE_CHECKING

            {imports_block}

            if TYPE_CHECKING:
                from multiconn_archicad.core.core_commands import CoreCommands

            class {class_name}:
                def __init__(self, core: CoreCommands):
                    self._core = core
        """).strip()

        indented_methods = "\n\n".join(textwrap.indent(method, "    ") for method in methods)
        return f"{header}\n\n{indented_methods}\n"

    def _assemble_main_api_file(self):
        """Generates the top-level api.py that ties everything together."""
        print("  - Assembling main api.py file...")
        imports = []
        container_classes = []

        for source in ["tapir", "official"]:
            classes = sorted(self._class_info[source], key=lambda i: i["module"])
            container_name = f"{source.capitalize()}Api"

            for info in classes:
                imports.append(f"from .{source}.{info['module']} import {info['class']}")

            class_body_lines = [
                f"class {container_name}:",
                f'    """A container for all command groups of the Archicad {source.capitalize()} API."""',
                "    def __init__(self, core: CoreCommands):",
            ]
            if not classes:
                class_body_lines.append("        pass")
            for info in classes:
                class_body_lines.append(f"        self.{info['module']} = {info['class']}(core)")

            container_classes.append("\n".join(class_body_lines))

        unique_imports = sorted(list(set(imports)))

        final_content = (
            textwrap.dedent("""
            # This file is automatically generated by the build system.
            # Do not edit this file directly.

            from __future__ import annotations
            from typing import TYPE_CHECKING

            {imports_block}

            if TYPE_CHECKING:
                from multiconn_archicad.core.core_commands import CoreCommands


            # --- Container class for Tapir commands ---
            {tapir_container_class}


            # --- Container class for Official commands ---
            {official_container_class}


            class UnifiedApi:
                \"\"\"
                A unified, high-level, object-oriented interface for both the Tapir
                and Official Archicad JSON APIs, organized by command groups.
                \"\"\"
                def __init__(self, core: CoreCommands):
                    self.tapir = TapirApi(core)
                    self.official = OfficialApi(core)
        """)
            .format(
                imports_block="\n".join(unique_imports),
                tapir_container_class=container_classes[0],
                official_container_class=container_classes[1],
            )
            .strip()
        )

        output_path = self._output_dir / "api.py"
        output_path.write_text(final_content, encoding="utf-8")


def main():
    """Main script for Stage 3 of the pipeline."""
    parser = argparse.ArgumentParser(description="Stage 3: Assemble final API Python files from enriched JSON data.")
    parser.add_argument(
        "--input-file",
        required=True,
        type=pathlib.Path,
        help="Path to commands JSON with generated code (from Stage 2).",
    )
    parser.add_argument(
        "--output-dir", required=True, type=pathlib.Path, help="Final output directory for the generated API package."
    )
    args = parser.parse_args()

    if not args.input_file.is_file():
        print(f"❌ FATAL: Input file not found at: {args.input_file}", file=sys.stderr)
        sys.exit(1)

    with open(args.input_file, "r", encoding="utf-8") as f:
        commands_with_code = json.load(f)

    assembler = FileAssembler(commands_with_code, args.output_dir)
    assembler.assemble()


if __name__ == "__main__":
    main()
