from __future__ import annotations
from typing import Any, List, Literal, Annotated, TypeAlias
from uuid import UUID
from enum import Enum
from pydantic import Field, RootModel

from multiconn_archicad.models.base import APIModel

### This file is automatically generated and surgically cleaned. Do not edit directly. ###


class SurfaceType(Enum):
    General = "General"
    Simple = "Simple"
    Matte = "Matte"
    Metal = "Metal"
    Plastic = "Plastic"
    Glass = "Glass"
    Glowing = "Glowing"
    Constant = "Constant"


class AttributeType(Enum):
    Layer = "Layer"
    Line = "Line"
    Fill = "Fill"
    Composite = "Composite"
    Surface = "Surface"
    LayerCombination = "LayerCombination"
    ZoneCategory = "ZoneCategory"
    Profile = "Profile"
    PenTable = "PenTable"
    MEPSystem = "MEPSystem"
    OperationProfile = "OperationProfile"
    BuildingMaterial = "BuildingMaterial"


class GDLParameterDetails(APIModel):
    name: Annotated[str | None, Field(description="The name of the parameter.")] = None
    index: Annotated[str, Field(description="The index of the parameter.")]
    type: Annotated[str, Field(description="The type of the parameter.")]
    dimension1: Annotated[
        float | None,
        Field(description="The 1st dimension of array (in case of array value)."),
    ] = None
    dimension2: Annotated[
        float | None,
        Field(description="The 2nd dimension of array (in case of array value)."),
    ] = None
    value: Annotated[Any, Field(description="The value of the parameter.")]


class PolyArc(APIModel):
    begIndex: Annotated[
        int, Field(description="Node index of one end point of the arc.")
    ]
    endIndex: Annotated[
        int, Field(description="Node index of the other end point of the arc.")
    ]
    arcAngle: Annotated[
        float,
        Field(
            description="Angle of the arc; it is positive, if the arc is on the right-hand side of the straight segment."
        ),
    ]


class Coordinate2D(APIModel):
    x: Annotated[float, Field(description="X value of the coordinate.")]
    y: Annotated[float, Field(description="Y value of the coordinate.")]


class Coordinate3D(APIModel):
    x: Annotated[float, Field(description="X value of the coordinate.")]
    y: Annotated[float, Field(description="Y value of the coordinate.")]
    z: Annotated[float, Field(description="Z value of the coordinate.")]


class Dimensions3D(APIModel):
    x: Annotated[float, Field(description="X dimension.")]
    y: Annotated[float, Field(description="Y dimension.")]
    z: Annotated[float, Field(description="Z dimension.")]


class ColorRGB(APIModel):
    red: Annotated[float, Field(description="Red value between 0.0 and 1.0")]
    green: Annotated[float, Field(description="Green value between 0.0 and 1.0")]
    blue: Annotated[float, Field(description="Blue value between 0.0 and 1.0")]


class Texture(APIModel):
    name: Annotated[
        str,
        Field(
            description="The filename of the texture in the library (without extension)."
        ),
    ]
    rotationAngle: Annotated[
        float | None, Field(description="Rotation angle in radians.")
    ] = None
    xSize: Annotated[
        float | None,
        Field(description="X size of the picture in model space, by default 1."),
    ] = None
    ySize: Annotated[
        float | None,
        Field(description="Y size of the picture in model space, by default 1."),
    ] = None
    FillRectangle: Annotated[
        bool | None,
        Field(
            description="True, if fit the rectangle with the picture in a central position, using the natural aspect ratio of the picture."
        ),
    ] = None
    FitPicture: Annotated[
        bool | None,
        Field(
            description="True, if fit the picture in the middle of the rectangle, using the natural aspect ratio of the picture."
        ),
    ] = None
    mirrorX: Annotated[
        bool | None,
        Field(description="True, if the texture is mirrored in X direction."),
    ] = None
    mirrorY: Annotated[
        bool | None,
        Field(description="True, if the texture is mirrored in Y direction."),
    ] = None
    useAlphaChannel: Annotated[
        bool | None,
        Field(description="True, if the alpha channel of the texture is used."),
    ] = None
    alphaChannelChangesTransparency: Annotated[
        bool | None,
        Field(
            description="True, if the alpha channel of the texture changes the transparency."
        ),
    ] = None
    alphaChannelChangesSurfaceColor: Annotated[
        bool | None,
        Field(
            description="True, if the alpha channel of the texture changes the surface color."
        ),
    ] = None
    alphaChannelChangesAmbientColor: Annotated[
        bool | None,
        Field(
            description="True, if the alpha channel of the texture changes the ambient color."
        ),
    ] = None
    alphaChannelChangesSpecularColor: Annotated[
        bool | None,
        Field(
            description="True, if the alpha channel of the texture changes the specular color."
        ),
    ] = None
    alphaChannelChangesDiffuseColor: Annotated[
        bool | None,
        Field(
            description="True, if the alpha channel of the texture changes the diffuse color."
        ),
    ] = None


class Error(APIModel):
    code: Annotated[int, Field(description="The code of the error.")]
    message: Annotated[str, Field(description="The error message.")]


class ErrorItem(APIModel):
    error: Error


class SuccessfulExecutionResult(APIModel):
    success: Literal[True] = True


class FailedExecutionResult(APIModel):
    success: Literal[False] = False
    error: Annotated[Error, Field(description="The details of an execution failure.")]


class ElementType(Enum):
    Wall = "Wall"
    Column = "Column"
    Beam = "Beam"
    Window = "Window"
    Door = "Door"
    Object = "Object"
    Lamp = "Lamp"
    Slab = "Slab"
    Roof = "Roof"
    Mesh = "Mesh"
    Dimension = "Dimension"
    RadialDimension = "RadialDimension"
    LevelDimension = "LevelDimension"
    AngleDimension = "AngleDimension"
    Text = "Text"
    Label = "Label"
    Zone = "Zone"
    Hatch = "Hatch"
    Line = "Line"
    PolyLine = "PolyLine"
    Arc = "Arc"
    Circle = "Circle"
    Spline = "Spline"
    Hotspot = "Hotspot"
    CutPlane = "CutPlane"
    Camera = "Camera"
    CamSet = "CamSet"
    Group = "Group"
    SectElem = "SectElem"
    Drawing = "Drawing"
    Picture = "Picture"
    Detail = "Detail"
    Elevation = "Elevation"
    InteriorElevation = "InteriorElevation"
    Worksheet = "Worksheet"
    Hotlink = "Hotlink"
    CurtainWall = "CurtainWall"
    CurtainWallSegment = "CurtainWallSegment"
    CurtainWallFrame = "CurtainWallFrame"
    CurtainWallPanel = "CurtainWallPanel"
    CurtainWallJunction = "CurtainWallJunction"
    CurtainWallAccessory = "CurtainWallAccessory"
    Shell = "Shell"
    Skylight = "Skylight"
    Morph = "Morph"
    ChangeMarker = "ChangeMarker"
    Stair = "Stair"
    Riser = "Riser"
    Tread = "Tread"
    StairStructure = "StairStructure"
    Railing = "Railing"
    RailingToprail = "RailingToprail"
    RailingHandrail = "RailingHandrail"
    RailingRail = "RailingRail"
    RailingPost = "RailingPost"
    RailingInnerPost = "RailingInnerPost"
    RailingBaluster = "RailingBaluster"
    RailingPanel = "RailingPanel"
    RailingSegment = "RailingSegment"
    RailingNode = "RailingNode"
    RailingBalusterSet = "RailingBalusterSet"
    RailingPattern = "RailingPattern"
    RailingToprailEnd = "RailingToprailEnd"
    RailingHandrailEnd = "RailingHandrailEnd"
    RailingRailEnd = "RailingRailEnd"
    RailingToprailConnection = "RailingToprailConnection"
    RailingHandrailConnection = "RailingHandrailConnection"
    RailingRailConnection = "RailingRailConnection"
    RailingEndFinish = "RailingEndFinish"
    BeamSegment = "BeamSegment"
    ColumnSegment = "ColumnSegment"
    Opening = "Opening"
    Unknown = "Unknown"


class ElementFilter(Enum):
    IsEditable = "IsEditable"
    IsVisibleByLayer = "IsVisibleByLayer"
    IsVisibleByRenovation = "IsVisibleByRenovation"
    IsVisibleByStructureDisplay = "IsVisibleByStructureDisplay"
    IsVisibleIn3D = "IsVisibleIn3D"
    OnActualFloor = "OnActualFloor"
    OnActualLayout = "OnActualLayout"
    InMyWorkspace = "InMyWorkspace"
    IsIndependent = "IsIndependent"
    InCroppedView = "InCroppedView"
    HasAccessRight = "HasAccessRight"
    IsOverriddenByRenovation = "IsOverriddenByRenovation"


class WindowType(Enum):
    FloorPlan = "FloorPlan"
    Section = "Section"
    Details = "Details"
    field_3DModel = "3DModel"
    Layout = "Layout"
    Drawing = "Drawing"
    CustomText = "CustomText"
    CustomDraw = "CustomDraw"
    MasterLayout = "MasterLayout"
    Elevation = "Elevation"
    InteriorElevation = "InteriorElevation"
    Worksheet = "Worksheet"
    Report = "Report"
    field_3DDocument = "3DDocument"
    External3D = "External3D"
    Movie3D = "Movie3D"
    MovieRendering = "MovieRendering"
    Rendering = "Rendering"
    ModelCompare = "ModelCompare"
    Interactive_Schedule = "Interactive Schedule"
    Unknown = "Unknown"


class IssueId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class IssueIdArrayItem(APIModel):
    issueId: IssueId


class IssueElementType(Enum):
    Creation = "Creation"
    Highlight = "Highlight"
    Deletion = "Deletion"
    Modification = "Modification"


class IssueCommentStatus(Enum):
    Error = "Error"
    Warning = "Warning"
    Info = "Info"
    Unknown = "Unknown"


class PropertyGroupId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class PropertyGroupIdArrayItem(APIModel):
    propertyGroupId: PropertyGroupId


class PropertyId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class PropertyIdArrayItem(APIModel):
    propertyId: PropertyId


class PropertyType(Enum):
    StaticBuiltIn = "StaticBuiltIn"
    DynamicBuiltIn = "DynamicBuiltIn"
    Custom = "Custom"


class PropertyCollectionType(Enum):
    Undefined = "Undefined"
    Single = "Single"
    List = "List"
    SingleChoiceEnumeration = "SingleChoiceEnumeration"
    MultipleChoiceEnumeration = "MultipleChoiceEnumeration"


class PropertyValueType(Enum):
    Undefined = "Undefined"
    Integer = "Integer"
    Real = "Real"
    String = "String"
    Boolean = "Boolean"
    Guid = "Guid"


class PropertyMeasureType(Enum):
    Undefined = "Undefined"
    Default = "Default"
    Length = "Length"
    Area = "Area"
    Volume = "Volume"
    Angle = "Angle"


class PropertyDetails(APIModel):
    propertyId: PropertyId
    propertyType: PropertyType
    propertyGroupName: str
    propertyName: str
    propertyCollectionType: PropertyCollectionType
    propertyValueType: PropertyValueType
    propertyMeasureType: PropertyMeasureType
    propertyIsEditable: bool


class PropertyValue(APIModel):
    value: str


class PropertyValueArrayItem(APIModel):
    propertyValue: PropertyValue


class PropertyValuesArrayItem(APIModel):
    propertyValues: Annotated[
        List[PropertyValueArrayItem | ErrorItem],
        Field(description="A list of property values."),
    ]


class PropertyDataType(Enum):
    number = "number"
    integer = "integer"
    string = "string"
    boolean = "boolean"
    length = "length"
    area = "area"
    volume = "volume"
    angle = "angle"
    numberList = "numberList"
    integerList = "integerList"
    stringList = "stringList"
    booleanList = "booleanList"
    lengthList = "lengthList"
    areaList = "areaList"
    volumeList = "volumeList"
    angleList = "angleList"
    singleEnum = "singleEnum"
    multiEnum = "multiEnum"


class DisplayValueEnumId(APIModel):
    type: Literal["displayValue"] = "displayValue"
    displayValue: str


class NonLocalizedValueEnumId(APIModel):
    type: Literal["nonLocalizedValue"] = "nonLocalizedValue"
    nonLocalizedValue: str


class EnumValueIdArrayItem(APIModel):
    enumValueId: Annotated[
        DisplayValueEnumId | NonLocalizedValueEnumId,
        Field(description="The identifier of a property enumeration value."),
    ]


class UserUndefinedPropertyValue(APIModel):
    type: PropertyDataType
    status: Literal["userUndefined"] = "userUndefined"


class NotAvailablePropertyValue(APIModel):
    type: PropertyDataType
    status: Literal["notAvailable"] = "notAvailable"


class NormalNumberPropertyValue(APIModel):
    type: Literal["number"] = "number"
    status: Literal["normal"] = "normal"
    value: float


class NormalIntegerPropertyValue(APIModel):
    type: Literal["integer"] = "integer"
    status: Literal["normal"] = "normal"
    value: int


class NormalStringPropertyValue(APIModel):
    type: Literal["string"] = "string"
    status: Literal["normal"] = "normal"
    value: str


class NormalBooleanPropertyValue(APIModel):
    type: Literal["boolean"] = "boolean"
    status: Literal["normal"] = "normal"
    value: bool


class NormalLengthPropertyValue(APIModel):
    type: Literal["length"] = "length"
    status: Literal["normal"] = "normal"
    value: float


class NormalAreaPropertyValue(APIModel):
    type: Literal["area"] = "area"
    status: Literal["normal"] = "normal"
    value: float


class NormalVolumePropertyValue(APIModel):
    type: Literal["volume"] = "volume"
    status: Literal["normal"] = "normal"
    value: float


class NormalAnglePropertyValue(APIModel):
    type: Literal["angle"] = "angle"
    status: Literal["normal"] = "normal"
    value: float


class NormalNumberListPropertyValue(APIModel):
    type: Literal["numberList"] = "numberList"
    status: Literal["normal"] = "normal"
    value: List[float]


class NormalIntegerListPropertyValue(APIModel):
    type: Literal["integerList"] = "integerList"
    status: Literal["normal"] = "normal"
    value: List[int]


class NormalStringListPropertyValue(APIModel):
    type: Literal["stringList"] = "stringList"
    status: Literal["normal"] = "normal"
    value: List[str]


class NormalBooleanListPropertyValue(APIModel):
    type: Literal["booleanList"] = "booleanList"
    status: Literal["normal"] = "normal"
    value: List[bool]


class NormalLengthListPropertyValue(APIModel):
    type: Literal["lengthList"] = "lengthList"
    status: Literal["normal"] = "normal"
    value: List[float]


class NormalAreaListPropertyValue(APIModel):
    type: Literal["areaList"] = "areaList"
    status: Literal["normal"] = "normal"
    value: List[float]


class NormalVolumeListPropertyValue(APIModel):
    type: Literal["volumeList"] = "volumeList"
    status: Literal["normal"] = "normal"
    value: List[float]


class NormalAngleListPropertyValue(APIModel):
    type: Literal["angleList"] = "angleList"
    status: Literal["normal"] = "normal"
    value: List[float]


class NormalSingleEnumPropertyValue(APIModel):
    type: Literal["singleEnum"] = "singleEnum"
    status: Literal["normal"] = "normal"
    value: Annotated[
        DisplayValueEnumId | NonLocalizedValueEnumId,
        Field(description="The identifier of a property enumeration value."),
    ]


class NormalMultiEnumPropertyValue(APIModel):
    type: Literal["multiEnum"] = "multiEnum"
    status: Literal["normal"] = "normal"
    value: Annotated[
        List[EnumValueIdArrayItem],
        Field(description="A list of enumeration identifiers."),
    ]


class ExpressionDefaultValue(APIModel):
    expressions: List[str]


class ClassificationSystemId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class ClassificationSystemIdArrayItem(APIModel):
    classificationSystemId: ClassificationSystemId


class ClassificationItemId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class ClassificationItemIdArrayItem(APIModel):
    classificationItemId: ClassificationItemId


class ClassificationId(APIModel):
    classificationSystemId: ClassificationSystemId
    classificationItemId: Annotated[
        ClassificationItemId | None,
        Field(
            description="The element's classification in the given system. If no value is specified here, the element is Unclassified in this system."
        ),
    ] = None


class ClassificationIdArrayItem(APIModel):
    classificationId: ClassificationId


class ElementClassificationItemArray(APIModel):
    classificationIds: Annotated[
        List[ClassificationIdArrayItem | ErrorItem],
        Field(description="A list of element classification identifiers or errors."),
    ]


class BoundingBox3D(APIModel):
    xMin: Annotated[
        float, Field(description="The minimum X value of the bounding box.")
    ]
    yMin: Annotated[
        float, Field(description="The minimum Y value of the bounding box.")
    ]
    zMin: Annotated[
        float, Field(description="The minimum Z value of the bounding box.")
    ]
    xMax: Annotated[
        float, Field(description="The maximum X value of the bounding box.")
    ]
    yMax: Annotated[
        float, Field(description="The maximum Y value of the bounding box.")
    ]
    zMax: Annotated[
        float, Field(description="The maximum Z value of the bounding box.")
    ]


class BoundingBox3DArrayItem(APIModel):
    boundingBox3D: BoundingBox3D


class LibPartUnId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class LibPartDetails(APIModel):
    name: str
    parentUnID: LibPartUnId
    ownUnID: LibPartUnId


class NavigatorItemId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class DatabaseId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class ViewSettings(APIModel):
    modelViewOptions: Annotated[
        str | None,
        Field(
            description="The name of the model view options. If empty, the view has custom model view options."
        ),
    ] = None
    layerCombination: Annotated[
        str | None,
        Field(
            description="The name of the layer combination. If empty, the view has custom layer combination."
        ),
    ] = None
    dimensionStyle: Annotated[
        str | None,
        Field(
            description="The name of the dimension style. If empty, the view has custom dimension style."
        ),
    ] = None
    penSetName: Annotated[
        str | None,
        Field(
            description="The name of the pen set. If empty, the view has custom pen set."
        ),
    ] = None
    graphicOverrideCombination: Annotated[
        str | None,
        Field(
            description="The name of the graphic override combination. If empty, the view has custom graphic override combination."
        ),
    ] = None


class Zoom(APIModel):
    xMin: Annotated[float, Field(description="The minimum X value of the zoom box.")]
    yMin: Annotated[float, Field(description="The minimum Y value of the zoom box.")]
    xMax: Annotated[float, Field(description="The maximum X value of the zoom box.")]
    yMax: Annotated[float, Field(description="The maximum Y value of the zoom box.")]


class ViewTransformations(APIModel):
    zoom: Annotated[
        Zoom,
        Field(
            description="The actual zoom parameters, rectangular region of the model."
        ),
    ]
    rotation: Annotated[float, Field(description="The orientation in radian.")]


class Hole2D(APIModel):
    polygonOutline: Annotated[
        List[Coordinate2D] | None,
        Field(description="The 2D coordinates of the edge of the hole.", min_length=3),
    ] = None
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the hole.")
    ] = None


class Hole3D(APIModel):
    polygonCoordinates: Annotated[
        List[Coordinate3D],
        Field(
            description="The 3D coordinates of the polygon of the hole.", min_length=3
        ),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the hole.")
    ] = None


class GeometryType(Enum):
    Straight = "Straight"
    Trapezoid = "Trapezoid"
    Polygonal = "Polygonal"


class WallDetails(APIModel):
    geometryType: GeometryType
    begCoordinate: Coordinate2D
    endCoordinate: Coordinate2D
    zCoordinate: float
    height: Annotated[float, Field(description="height relative to bottom")]
    bottomOffset: Annotated[
        float, Field(description="base level of the wall relative to the floor level")
    ]
    offset: Annotated[
        float, Field(description="wall's base line's offset from ref. line")
    ]
    arcAngle: Annotated[
        float | None, Field(description="The arc angle of the curved wall in radians.")
    ] = None
    begThickness: Annotated[
        float | None,
        Field(description="Thickness at the beginning in case of trapezoid wall"),
    ] = None
    endThickness: Annotated[
        float | None,
        Field(description="Thickness at the end in case of trapezoid wall"),
    ] = None
    polygonOutline: Annotated[
        List[Coordinate2D] | None,
        Field(description="Polygon outline in case of polygonal wall"),
    ] = None
    polygonArcs: Annotated[
        List[PolyArc] | None,
        Field(description="Polygon arcs in case of polygonal wall"),
    ] = None


class BeamDetails(APIModel):
    begCoordinate: Coordinate2D
    endCoordinate: Coordinate2D
    zCoordinate: float
    level: Annotated[
        float, Field(description="base height of the beam relative to the floor level")
    ]
    offset: Annotated[float, Field(description="beam ref.line offset from the center")]
    slantAngle: Annotated[
        float, Field(description="The slant angle of the beam in radians.")
    ]
    arcAngle: Annotated[
        float,
        Field(
            description="The arc angle of the (horizontally) curved beam in radians."
        ),
    ]
    verticalCurveHeight: Annotated[
        float, Field(description="The height of the vertical curve of the beam.")
    ]


class SlabDetails(APIModel):
    thickness: Annotated[float, Field(description="Thickness of the slab.")]
    level: Annotated[
        float,
        Field(
            description="Distance of the reference level of the slab from the floor level."
        ),
    ]
    offsetFromTop: Annotated[
        float,
        Field(
            description="Vertical distance between the reference level and the top of the slab."
        ),
    ]
    zCoordinate: float
    polygonOutline: Annotated[
        List[Coordinate2D], Field(description="Polygon outline of the slab.")
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the slab.")
    ] = None
    holes: Annotated[
        List[Hole2D],
        Field(
            description="A list of 2D holes in an element defined by closed polylines"
        ),
    ]


class ColumnDetails(APIModel):
    origin: Coordinate2D
    zCoordinate: float
    height: Annotated[float, Field(description="height relative to bottom")]
    bottomOffset: Annotated[
        float, Field(description="base level of the column relative to the floor level")
    ]


class ObjectDetails(APIModel):
    origin: Coordinate3D
    dimensions: Coordinate3D
    angle: float


class PolylineDetails(APIModel):
    coordinates: List[Coordinate2D]
    arcs: Annotated[
        List[PolyArc] | None, Field(description="The arcs of the polyline.")
    ] = None
    zCoordinate: float


class CurtainWallDetails(APIModel):
    height: float | None = None
    angle: Annotated[
        float | None,
        Field(description="The rotation angle of the curtain wall in radians."),
    ] = None


class CurtainWallSegmentDetails(APIModel):
    begCoordinate: Coordinate3D
    endCoordinate: Coordinate3D
    extrusionVector: Coordinate3D
    gridOrigin: Coordinate3D
    gridAngle: Annotated[float, Field(description="The angle of the grid in radians.")]
    arcOrigin: Coordinate3D | None = None
    isNegativeArc: Annotated[
        bool | None, Field(description="Indicates if the arc is negative.")
    ] = None


class PanelConnectionHole(APIModel):
    d: Annotated[float, Field(description="Depth of the panel connection hole.")]
    w: Annotated[float, Field(description="Width of the panel connection hole.")]


class FrameContour(APIModel):
    a1: Annotated[float, Field(description="Width1 of the frame contour.")]
    a2: Annotated[float, Field(description="Width2 of the frame contour.")]
    b1: Annotated[float, Field(description="Length1 of the frame contour.")]
    b2: Annotated[float, Field(description="Length2 of the frame contour.")]


class Type(Enum):
    Deleted = "Deleted"
    Division = "Division"
    Corner = "Corner"
    Boundary = "Boundary"
    Custom = "Custom"


class CurtainWallFrameDetails(APIModel):
    begCoordinate: Coordinate3D
    endCoordinate: Coordinate3D
    orientationVector: Coordinate3D
    panelConnectionHole: Annotated[
        PanelConnectionHole,
        Field(description="The parameters of the panel connection hole."),
    ]
    frameContour: Annotated[
        FrameContour, Field(description="The parameters of the frame contour.")
    ]
    segmentIndex: Annotated[
        float,
        Field(
            description="The index of the curtain wall segment to which this frame belongs."
        ),
    ]
    className: str
    type: Type


class MeshSkirtType(Enum):
    SurfaceOnlyWithoutSkirt = "SurfaceOnlyWithoutSkirt"
    WithSkirt = "WithSkirt"
    SolidBodyWithSkirt = "SolidBodyWithSkirt"


class Subline(APIModel):
    coordinates: Annotated[
        List[Coordinate3D],
        Field(description="The 3D coordinates of the leveling subline of the mesh."),
    ]


class MeshDetails(APIModel):
    level: Annotated[float, Field(description="The Z reference level of coordinates.")]
    skirtType: MeshSkirtType
    skirtLevel: Annotated[float, Field(description="The height of the skirt.")]
    polygonCoordinates: Annotated[
        List[Coordinate3D],
        Field(
            description="The 3D coordinates of the outline polygon of the mesh.",
            min_length=3,
        ),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the mesh.")
    ] = None
    holes: Annotated[
        List[Hole3D] | None,
        Field(
            description="A list of 3D holes in an element defined by closed polylines"
        ),
    ] = None
    sublines: Annotated[
        List[Subline] | None,
        Field(
            description="The leveling sublines inside the polygon of the mesh.",
            min_length=1,
        ),
    ] = None


class NotYetSupportedElementTypeDetails(APIModel):
    error: str


class RevisionIssueId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class DocumentRevisionId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class RevisionCustomSchemeDatum(APIModel):
    customSchemeKey: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]
    customSchemeValue: str


class DocumentRevisionReference(APIModel):
    revisionId: DocumentRevisionId


class RevisionIssue(APIModel):
    revisionIssueId: RevisionIssueId
    id: str
    description: str
    issueTime: str
    issuedByUser: str
    overrideRevisionIDOfAllIncludedLayouts: bool
    createNewRevisionInAllIncludedLayouts: bool
    markersVisibleSinceIndex: int | None = None
    isIssued: bool
    documentRevisions: Annotated[
        List[DocumentRevisionReference] | None,
        Field(description="All document revisions belong to the current issue."),
    ] = None
    customSchemeData: List[RevisionCustomSchemeDatum] | None = None


class RevisionChange(APIModel):
    id: str
    description: str
    lastModifiedTime: str
    modifiedByUser: str
    isIssued: bool
    firstRevisionIssueId: Annotated[
        RevisionIssueId | None,
        Field(
            description="The identifier of the first issue in which the given change is issued."
        ),
    ] = None
    isArchived: bool
    customSchemeData: List[RevisionCustomSchemeDatum] | None = None


class LayoutInfo(APIModel):
    id: str
    databaseId: DatabaseId
    name: str
    masterLayoutName: str
    width: float
    height: float
    subsetId: str
    subsetName: str
    ownerUser: str
    customSchemeData: List[RevisionCustomSchemeDatum] | None = None


class Status(Enum):
    Actual = "Actual"
    Issued = "Issued"


class Change(APIModel):
    id: str


class DocumentRevision(APIModel):
    revisionId: DocumentRevisionId
    id: str
    finalId: str
    ownerUser: str
    status: Status
    changes: Annotated[
        List[Change] | None,
        Field(description="All changes belong to the given document revision."),
    ] = None
    layoutInfo: LayoutInfo


class RevisionChangesArrayItem(APIModel):
    revisionChanges: List[RevisionChange] | None = None


class StoryParameters(APIModel):
    index: Annotated[int, Field(description="The story index.")]
    floorId: Annotated[int, Field(description="Unique ID of the story.")]
    dispOnSections: Annotated[
        bool,
        Field(
            description="Story level lines should appear on sections and elevations."
        ),
    ]
    level: Annotated[float, Field(description="The story level.")]
    name: Annotated[str, Field(description="The name of the story.")]


class StorySettings(APIModel):
    dispOnSections: Annotated[
        bool,
        Field(
            description="Story level lines should appear on sections and elevations."
        ),
    ]
    level: Annotated[float, Field(description="The story level.")]
    name: Annotated[str, Field(description="The name of the story.")]


class AutomaticZoneGeometry(APIModel):
    referencePosition: Annotated[
        Coordinate2D, Field(description="Reference point to automatically find zone.")
    ]


class ManualZoneGeometry(APIModel):
    polygonCoordinates: Annotated[
        List[Coordinate2D],
        Field(description="The 2D coordinates of the edge of the zone.", min_length=3),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the zone.")
    ] = None
    holes: Annotated[
        List[Hole2D] | None,
        Field(
            description="A list of 2D holes in an element defined by closed polylines"
        ),
    ] = None


class WallSettings(APIModel):
    begCoordinate: Coordinate2D | None = None
    endCoordinate: Coordinate2D | None = None
    height: Annotated[float | None, Field(description="height relative to bottom")] = (
        None
    )
    bottomOffset: Annotated[
        float | None,
        Field(description="base level of the wall relative to the floor level"),
    ] = None
    offset: Annotated[
        float | None, Field(description="wall's base line's offset from ref. line")
    ] = None
    begThickness: Annotated[
        float | None,
        Field(description="Thickness at the beginning in case of trapezoid wall"),
    ] = None
    endThickness: Annotated[
        float | None,
        Field(description="Thickness at the end in case of trapezoid wall"),
    ] = None


TypeSpecificSettings: TypeAlias = WallSettings


class PropertyGroup(APIModel):
    name: str
    description: str | None = None


class PropertyGroupArrayItem(APIModel):
    propertyGroup: PropertyGroup


class EnumValue(APIModel):
    enumValueId: Annotated[
        DisplayValueEnumId | NonLocalizedValueEnumId | None,
        Field(description="The identifier of a property enumeration value."),
    ] = None
    displayValue: Annotated[
        str, Field(description="Displayed value of the enumeration.")
    ]
    nonLocalizedValue: Annotated[
        str | None,
        Field(description="Nonlocalized value of the enumeration if there is one."),
    ] = None


class PossibleEnumValue(APIModel):
    enumValue: Annotated[
        EnumValue, Field(description="The description of an enumeration value.")
    ]


class Group(APIModel):
    propertyGroupId: PropertyGroupId | None = None
    name: str | None = None


class GetAddOnVersionResult(APIModel):
    version: Annotated[
        str, Field(description='Version number in the form of "1.1.1".', min_length=1)
    ]


class GetArchicadLocationResult(APIModel):
    archicadLocation: Annotated[
        str,
        Field(
            description="The location of the Archicad executable in the filesystem.",
            min_length=1,
        ),
    ]


class GetCurrentWindowTypeResult(APIModel):
    currentWindowType: WindowType


class GetProjectInfoResult(APIModel):
    isUntitled: Annotated[
        bool, Field(description="True, if the project is not saved yet.")
    ]
    isTeamwork: Annotated[
        bool,
        Field(description="True, if the project is a Teamwork (BIMcloud) project."),
    ]
    projectLocation: Annotated[
        str | None,
        Field(
            description="The location of the project in the filesystem or a BIMcloud project reference.",
            min_length=1,
        ),
    ] = None
    projectPath: Annotated[
        str | None,
        Field(
            description="The path of the project. A filesystem path or a BIMcloud server relative path.",
            min_length=1,
        ),
    ] = None
    projectName: Annotated[
        str | None, Field(description="The name of the project.", min_length=1)
    ] = None


class FieldModel(APIModel):
    projectInfoId: Annotated[
        str | None, Field(description="The id of the project info field.")
    ] = None
    projectInfoName: Annotated[
        str | None,
        Field(description="The name of the project info field visible on UI."),
    ] = None
    projectInfoValue: Annotated[
        str | None, Field(description="The value of the project info field.")
    ] = None


class GetProjectInfoFieldsResult(APIModel):
    fields: Annotated[
        List[FieldModel], Field(description="A list of project info fields.")
    ]


class SetProjectInfoFieldParameters(APIModel):
    projectInfoId: Annotated[
        str, Field(description="The id of the project info field.", min_length=1)
    ]
    projectInfoValue: Annotated[
        str, Field(description="The new value of the project info field.", min_length=1)
    ]


class GetStoriesResult(APIModel):
    firstStory: Annotated[int, Field(description="First story index.")]
    lastStory: Annotated[int, Field(description="Last story index.")]
    actStory: Annotated[
        int, Field(description="Actual (currently visible in 2D) story index.")
    ]
    skipNullFloor: Annotated[
        bool,
        Field(
            description="Floor indices above ground-floor level may start with 1 instead of 0."
        ),
    ]
    stories: Annotated[
        List[StoryParameters],
        Field(
            description="A list of project stories, each with their complete parameters."
        ),
    ]


class SetStoriesParameters(APIModel):
    stories: Annotated[
        List[StorySettings],
        Field(
            description="A list of story settings, used as input for creating or modifying multiple stories."
        ),
    ]


class OpenProjectParameters(APIModel):
    projectFilePath: Annotated[
        str, Field(description="The target project file to open.")
    ]


class ProjectLocation(APIModel):
    longitude: Annotated[float, Field(description="longitude in degrees")]
    latitude: Annotated[float, Field(description="latitude in degrees")]
    altitude: Annotated[float, Field(description="altitude in meters")]
    north: Annotated[float, Field(description="north direction in radians")]


class Position(APIModel):
    eastings: Annotated[
        float,
        Field(
            description="Location along the easting of the coordinate system of the target map coordinate reference system."
        ),
    ]
    northings: Annotated[
        float,
        Field(
            description="Location along the northing of the coordinate system of the target map coordinate reference system."
        ),
    ]
    elevation: Annotated[
        float,
        Field(
            description="Orthogonal height relative to the vertical datum specified."
        ),
    ]


class GeoReferencingParameters(APIModel):
    crsName: Annotated[
        str,
        Field(
            description="Name by which the coordinate reference system is identified."
        ),
    ]
    description: Annotated[
        str,
        Field(description="Informal description of this coordinate reference system."),
    ]
    geodeticDatum: Annotated[
        str, Field(description="Name by which this datum is identified.")
    ]
    verticalDatum: Annotated[
        str, Field(description="Name by which the vertical datum is identified.")
    ]
    mapProjection: Annotated[
        str, Field(description="Name by which the map projection is identified.")
    ]
    mapZone: Annotated[
        str,
        Field(
            description="Name by which the map zone, relating to the MapProjection, is identified."
        ),
    ]


class SurveyPoint(APIModel):
    position: Position
    geoReferencingParameters: GeoReferencingParameters


class GetGeoLocationResult(APIModel):
    projectLocation: ProjectLocation
    surveyPoint: SurveyPoint


class ChangeSelectionOfElementsResult(APIModel):
    executionResultsOfAddToSelection: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]
    executionResultsOfRemoveFromSelection: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class Details(APIModel):
    floorIndex: float | None = None
    layerIndex: float | None = None
    drawIndex: float | None = None
    typeSpecificDetails: TypeSpecificSettings | None = None


class SetDetailsOfElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class Get3DBoundingBoxesResult(APIModel):
    boundingBoxes3D: Annotated[
        List[BoundingBox3DArrayItem | ErrorItem],
        Field(description="A list of 3D bounding boxes."),
    ]


class Settings(APIModel):
    volumeTolerance: Annotated[
        float,
        Field(
            description="Intersection body volume greater then this value will be considered as a collision. Default value is 0.001."
        ),
    ]
    performSurfaceCheck: Annotated[
        bool,
        Field(
            description="Enables surface collision check. If disabled the surfaceTolerance value will be ignored. By default it's false."
        ),
    ]
    surfaceTolerance: Annotated[
        float,
        Field(
            description="Intersection body surface area greater then this value will be considered as a collision. Default value is 0.001."
        ),
    ]


HighlightedColor: TypeAlias = List[int]


class MoveVector(APIModel):
    x: Annotated[float, Field(description="X value of the vector.")]
    y: Annotated[float, Field(description="Y value of the vector.")]
    z: Annotated[float, Field(description="Z value of the vector.")]


class MoveElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class SetGDLParametersOfElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class GetClassificationsOfElementsResult(APIModel):
    elementClassifications: Annotated[
        List[ElementClassificationItemArray | ErrorItem],
        Field(
            description="The list of element classification item identifiers. Order of the ids are the same as in the input. Non-existing elements or non-existing classification systems are represented by error objects."
        ),
    ]


class SetClassificationsOfElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class Coordinates(APIModel):
    x: Annotated[float, Field(description="X value of the coordinate.")]
    y: Annotated[float, Field(description="Y value of the coordinate.")]
    z: Annotated[float, Field(description="Z value of the coordinate.")]


class ColumnsDatum(APIModel):
    coordinates: Annotated[Coordinates, Field(description="3D coordinate.")]


class CreateColumnsParameters(APIModel):
    columnsData: Annotated[
        List[ColumnsDatum], Field(description="Array of data to create Columns.")
    ]


class SlabsDatum(APIModel):
    level: Annotated[
        float,
        Field(description="The Z coordinate value of the reference line of the slab."),
    ]
    polygonCoordinates: Annotated[
        List[Coordinate2D],
        Field(description="The 2D coordinates of the edge of the slab.", min_length=3),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the slab.")
    ] = None
    holes: Annotated[
        List[Hole2D] | None,
        Field(
            description="A list of 2D holes in an element defined by closed polylines"
        ),
    ] = None


class CreateSlabsParameters(APIModel):
    slabsData: Annotated[
        List[SlabsDatum], Field(description="Array of data to create Slabs.")
    ]


class PolylinesDatum(APIModel):
    floorInd: Annotated[
        float | None,
        Field(
            description="The identifier of the floor. Optinal parameter, by default the current floor is used."
        ),
    ] = None
    coordinates: Annotated[
        List[Coordinate2D],
        Field(description="The 2D coordinates of the polyline.", min_length=2),
    ]
    arcs: Annotated[
        List[PolyArc] | None, Field(description="The arcs of the polyline.")
    ] = None


class CreatePolylinesParameters(APIModel):
    polylinesData: Annotated[
        List[PolylinesDatum], Field(description="Array of data to create Polylines.")
    ]


class ObjectsDatum(APIModel):
    libraryPartName: Annotated[
        str, Field(description="The name of the library part to use.")
    ]
    coordinates: Coordinate3D
    dimensions: Dimensions3D | None = None


class CreateObjectsParameters(APIModel):
    objectsData: Annotated[
        List[ObjectsDatum], Field(description="Array of data to create Objects.")
    ]


class MeshesDatum(APIModel):
    floorIndex: int | None = None
    level: Annotated[
        float | None, Field(description="The Z reference level of coordinates.")
    ] = None
    skirtType: MeshSkirtType | None = None
    skirtLevel: Annotated[
        float | None, Field(description="The height of the skirt.")
    ] = None
    polygonCoordinates: Annotated[
        List[Coordinate3D],
        Field(
            description="The 3D coordinates of the outline polygon of the mesh.",
            min_length=3,
        ),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the mesh.")
    ] = None
    holes: Annotated[
        List[Hole3D] | None,
        Field(
            description="A list of 3D holes in an element defined by closed polylines"
        ),
    ] = None
    sublines: Annotated[
        List[Subline] | None,
        Field(
            description="The leveling sublines inside the polygon of the mesh.",
            min_length=1,
        ),
    ] = None


class CreateMeshesParameters(APIModel):
    meshesData: Annotated[
        List[MeshesDatum], Field(description="Array of data to create Meshes.")
    ]


class GetFavoritesByTypeParameters(APIModel):
    elementType: ElementType


class GetFavoritesByTypeResult(APIModel):
    favorites: Annotated[List[str], Field(description="A list of favorite names")]


class ApplyFavoritesToElementDefaultsParameters(APIModel):
    favorites: Annotated[List[str], Field(description="A list of favorite names")]


class ApplyFavoritesToElementDefaultsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class CreateFavoritesFromElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class GetAllPropertiesResult(APIModel):
    properties: Annotated[
        List[PropertyDetails], Field(description="A list of property identifiers.")
    ]


class GetPropertyValuesOfElementsResult(APIModel):
    propertyValuesForElements: Annotated[
        List[PropertyValuesArrayItem | ErrorItem],
        Field(
            description="List of property value lists. The order of the outer list is that of the given elements. The order of the inner lists are that of the given properties."
        ),
    ]


class SetPropertyValuesOfElementsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class GetPropertyValuesOfAttributesResult(APIModel):
    propertyValuesForAttributes: Annotated[
        List[PropertyValuesArrayItem | ErrorItem],
        Field(
            description="List of property value lists. The order of the outer list is that of the given attributes. The order of the inner lists are that of the given properties."
        ),
    ]


class SetPropertyValuesOfAttributesResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class CreatePropertyGroupsParameters(APIModel):
    propertyGroups: Annotated[
        List[PropertyGroupArrayItem],
        Field(description="The parameters of the new property groups."),
    ]


class CreatePropertyGroupsResult(APIModel):
    propertyGroupIds: Annotated[
        List[PropertyGroupIdArrayItem],
        Field(description="The identifiers of the created property groups."),
    ]


class DeletePropertyGroupsParameters(APIModel):
    propertyGroupIds: Annotated[
        List[PropertyGroupIdArrayItem],
        Field(description="The identifiers of property groups to delete."),
    ]


class DeletePropertyGroupsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class CreatePropertyDefinitionsResult(APIModel):
    propertyIds: Annotated[
        List[PropertyIdArrayItem | ErrorItem],
        Field(description="A list of property identifiers."),
    ]


class DeletePropertyDefinitionsParameters(APIModel):
    propertyIds: Annotated[
        List[PropertyIdArrayItem],
        Field(description="The identifiers of properties to delete."),
    ]


class DeletePropertyDefinitionsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class GetAttributesByTypeParameters(APIModel):
    attributeType: AttributeType


class Properties(APIModel):
    thermalConductivity: Annotated[
        float | None, Field(description="Thermal Conductivity.")
    ] = None
    density: Annotated[float | None, Field(description="Density.")] = None
    heatCapacity: Annotated[float | None, Field(description="Heat Capacity.")] = None
    embodiedEnergy: Annotated[float | None, Field(description="Embodied Energy.")] = (
        None
    )
    embodiedCarbon: Annotated[float | None, Field(description="Embodied Carbon.")] = (
        None
    )


class Property(APIModel):
    properties: Annotated[
        Properties | None, Field(description="Physical properties.")
    ] = None


class GetBuildingMaterialPhysicalPropertiesResult(APIModel):
    properties: Annotated[
        List[Property], Field(description="Physical properties list.")
    ]


class Library(APIModel):
    name: Annotated[str, Field(description="Library name.")]
    path: Annotated[str, Field(description="A filesystem path to library location.")]
    type: Annotated[str, Field(description="Library type.")]
    available: Annotated[bool | None, Field(description="Is library not missing.")] = (
        None
    )
    readOnly: Annotated[bool | None, Field(description="Is library not writable.")] = (
        None
    )
    twServerUrl: Annotated[
        str | None,
        Field(description="URL address of the TeamWork server hosting the library."),
    ] = None
    urlWebLibrary: Annotated[
        str | None, Field(description="URL of the downloaded Internet library.")
    ] = None


class GetLibrariesResult(APIModel):
    libraries: Annotated[
        List[Library], Field(description="A list of project libraries.")
    ]


class Type1(Enum):
    Window = "Window"
    Door = "Door"
    Object = "Object"
    Lamp = "Lamp"
    Room = "Room"
    Property = "Property"
    PlanSign = "PlanSign"
    Label = "Label"
    Macro = "Macro"
    Pict = "Pict"
    ListScheme = "ListScheme"
    Skylight = "Skylight"
    OpeningSymbol = "OpeningSymbol"


class File(APIModel):
    inputPath: Annotated[str, Field(description="The path to the input file.")]
    outputPath: Annotated[
        str,
        Field(description="The relative path to the new file inside embedded library."),
    ]
    type: Annotated[
        Type1 | None,
        Field(description="The type of the library part. By default 'Pict'."),
    ] = None


class AddFilesToEmbeddedLibraryParameters(APIModel):
    files: Annotated[List[File], Field(description="A list of files")]


class AddFilesToEmbeddedLibraryResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class User(APIModel):
    userId: float
    userName: str


class PublishPublisherSetParameters(APIModel):
    publisherSetName: Annotated[
        str, Field(description="The name of the publisher set.", min_length=1)
    ]
    outputPath: Annotated[
        str | None,
        Field(
            description="Full local or LAN path for publishing. Optional, by default the path set in the settings of the publiser set will be used.",
            min_length=1,
        ),
    ] = None


class ModelViewOption(APIModel):
    name: str


class GetModelViewOptionsResult(APIModel):
    modelViewOptions: List[ModelViewOption]


class GetViewSettingsResult(APIModel):
    viewSettings: List[ViewSettings | ErrorItem]


class NavigatorItemIdsWithViewSetting(APIModel):
    navigatorItemId: NavigatorItemId
    viewSettings: ViewSettings


class SetViewSettingsParameters(APIModel):
    navigatorItemIdsWithViewSettings: List[NavigatorItemIdsWithViewSetting]


class SetViewSettingsResult(APIModel):
    executionResults: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult],
        Field(description="A list of execution results."),
    ]


class GetView2DTransformationsResult(APIModel):
    transformations: List[ViewTransformations | ErrorItem]


class CreateIssueParameters(APIModel):
    name: Annotated[str, Field(description="The name of the issue.")]
    parentIssueId: IssueId | None = None
    tagText: Annotated[
        str | None, Field(description="Tag text of the issue, optional.")
    ] = None


class CreateIssueResult(APIModel):
    issueId: IssueId


class DeleteIssueParameters(APIModel):
    issueId: IssueId
    acceptAllElements: Annotated[
        bool | None,
        Field(
            description="Accept all creation/deletion/modification of the deleted issue. By default false."
        ),
    ] = None


class AddCommentToIssueParameters(APIModel):
    issueId: IssueId
    author: Annotated[
        str | None, Field(description="The author of the new comment.")
    ] = None
    status: IssueCommentStatus | None = None
    text: Annotated[str, Field(description="Comment text to add.")]


class GetCommentsFromIssueParameters(APIModel):
    issueId: IssueId


class Comment(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="Comment identifier",
        ),
    ]
    author: Annotated[str, Field(description="Comment author")]
    text: Annotated[str, Field(description="Comment text")]
    status: IssueCommentStatus
    creaTime: Annotated[int, Field(description="Comment creation time")]


class GetCommentsFromIssueResult(APIModel):
    comments: Annotated[
        List[Comment], Field(description="A list of existing comments.")
    ]


class GetElementsAttachedToIssueParameters(APIModel):
    issueId: IssueId
    type: IssueElementType


class ExportIssuesToBCFParameters(APIModel):
    issues: Annotated[
        List[IssueIdArrayItem] | None,
        Field(description="Leave it empty to export all issues."),
    ] = None
    exportPath: Annotated[
        str, Field(description="The os path to the bcf file, including it's name.")
    ]
    useExternalId: Annotated[
        bool,
        Field(
            description="Use external IFC ID or Archicad IFC ID as referenced in BCF topics."
        ),
    ]
    alignBySurveyPoint: Annotated[
        bool,
        Field(
            description="Align BCF views by Archicad Survey Point or Archicad Project Origin."
        ),
    ]


class ImportIssuesFromBCFParameters(APIModel):
    importPath: Annotated[
        str, Field(description="The os path to the bcf file, including it's name.")
    ]
    alignBySurveyPoint: Annotated[
        bool,
        Field(
            description="Align BCF views by Archicad Survey Point or Archicad Project Origin."
        ),
    ]


class GetRevisionIssuesResult(APIModel):
    revisionIssues: List[RevisionIssue]


class GetRevisionChangesResult(APIModel):
    revisionChanges: List[RevisionChange]


class GetDocumentRevisionsResult(APIModel):
    documentRevisions: List[DocumentRevision]


class GetCurrentRevisionChangesOfLayoutsResult(APIModel):
    currentRevisionChangesOfLayouts: RevisionChangesArrayItem | ErrorItem


class GetRevisionChangesOfElementsResult(APIModel):
    revisionChangesOfElements: RevisionChangesArrayItem | ErrorItem


class GenerateDocumentationParameters(APIModel):
    destinationFolder: Annotated[
        str,
        Field(
            description="Destination folder for the generated documentation files.",
            min_length=1,
        ),
    ]


class ElementId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class AttributeId(APIModel):
    guid: Annotated[
        UUID,
        Field(
            description="A Globally Unique Identifier (or Universally Unique Identifier) in its string representation as defined in RFC 4122.",
        ),
    ]


class LayersOfLayerCombinationItem(APIModel):
    attributeId: Annotated[
        AttributeId, Field(description="The identifier of the Layer attribute.")
    ]
    isHidden: Annotated[
        bool, Field(description="Visibility of the Layer in the Layer Combination.")
    ]
    isLocked: Annotated[
        bool, Field(description="Lock state of the Layer in the Layer Combination.")
    ]
    isWireframe: Annotated[
        bool,
        Field(
            description="Is wireframe mode forced for the Layer in the Layer Combination."
        ),
    ]
    intersectionGroupNr: Annotated[
        int,
        Field(
            description="Intersection group of the Layer in the Layer Combination. Elements on layers having the same group will be intersected."
        ),
    ]


class LayerCombinationAttributeDetails(APIModel):
    attributeId: Annotated[
        AttributeId,
        Field(description="The identifier of the layer combination attribute."),
    ]
    attributeIndex: Annotated[
        int | None,
        Field(description="The index identifier of the layer combination attribute."),
    ] = None
    name: Annotated[str, Field(description="The name of the layer combination.")]
    layers: Annotated[
        List[LayersOfLayerCombinationItem],
        Field(description="List of Layers included in the Layer Combination."),
    ]


class LayerCombinationAttribute(APIModel):
    layerCombination: LayerCombinationAttributeDetails


class GDLParameterList(APIModel):
    parameters: Annotated[
        List[GDLParameterDetails], Field(description="The list of GDL parameters.")
    ]


class ElementPropertyValue(APIModel):
    elementId: ElementId
    propertyId: PropertyId
    propertyValue: PropertyValue


class AttributePropertyValue(APIModel):
    attributeId: AttributeId
    propertyId: PropertyId
    propertyValue: PropertyValue


class BasicDefaultValue(APIModel):
    basicDefaultValue: Annotated[
        NotAvailablePropertyValue
        | NormalNumberPropertyValue
        | NormalIntegerPropertyValue
        | NormalStringPropertyValue
        | NormalBooleanPropertyValue
        | NormalLengthPropertyValue
        | NormalAreaPropertyValue
        | NormalVolumePropertyValue
        | NormalAnglePropertyValue
        | NormalNumberListPropertyValue
        | NormalIntegerListPropertyValue
        | NormalStringListPropertyValue
        | NormalBooleanListPropertyValue
        | NormalLengthListPropertyValue
        | NormalAreaListPropertyValue
        | NormalVolumeListPropertyValue
        | NormalAngleListPropertyValue
        | NormalSingleEnumPropertyValue
        | NormalMultiEnumPropertyValue
        | UserUndefinedPropertyValue,
        Field(
            description="A normal, userUndefined, notAvailable or notEvaluated property value."
        ),
    ]


class ElementClassification(APIModel):
    elementId: ElementId
    classificationId: ClassificationId


class NavigatorItemIdArrayItem(APIModel):
    navigatorItemId: NavigatorItemId


class DatabaseIdArrayItem(APIModel):
    databaseId: DatabaseId


class LinkData(APIModel):
    referredView: Annotated[
        ElementId | None,
        Field(
            description="Guid of the referred view. Only if the marker refers to a view."
        ),
    ] = None
    referredDrawing: Annotated[
        ElementId | None,
        Field(
            description="Guid of the referred drawing. Only if the marker refers to a drawing."
        ),
    ] = None
    referredPMViewPoint: Annotated[
        ElementId | None,
        Field(
            description="Guid of the referred view point. Only if the marker refers to a view point."
        ),
    ] = None


class DetailWorksheetDetails(APIModel):
    basePoint: Annotated[
        Coordinate2D, Field(description="Coordinate of the base point")
    ]
    angle: Annotated[
        float, Field(description="The rotation angle (radian) of the marker symbol")
    ]
    markerId: Annotated[ElementId, Field(description="Guid of the marker symbol")]
    detailName: Annotated[str, Field(description="Name of the detail/worksheet")]
    detailIdStr: Annotated[
        str, Field(description="Reference ID of the detail/worksheet")
    ]
    isHorizontalMarker: Annotated[
        bool, Field(description="Marker symbol is always horizontal?")
    ]
    isWindowOpened: Annotated[
        bool, Field(description="Side (detail/worksheet) window is opened?")
    ]
    clipPolygon: Annotated[
        List[Coordinate2D],
        Field(description="The clip polygon of the detail/worksheet"),
    ]
    linkData: Annotated[LinkData, Field(description="The marker link data")]


class LibPartBasedElementDetails(APIModel):
    libPart: LibPartDetails
    ownerElementId: ElementId | None = None
    ownerElementType: ElementType | None = None


class ZoneDetails(APIModel):
    name: Annotated[str, Field(description="Name of the zone.")]
    numberStr: Annotated[str, Field(description="Zone number.")]
    categoryAttributeId: Annotated[
        AttributeId, Field(description="The identifier of the zone category attribute.")
    ]
    stampPosition: Annotated[
        Coordinate2D, Field(description="Position of the origin of the zone stamp.")
    ]
    isManual: Annotated[
        bool, Field(description="Is the coordinates of the zone manually placed?")
    ]
    polygonCoordinates: Annotated[
        List[Coordinate2D],
        Field(description="The 2D coordinates of the edge of the zone.", min_length=3),
    ]
    polygonArcs: Annotated[
        List[PolyArc] | None, Field(description="Polygon outline arcs of the zone.")
    ] = None
    holes: Annotated[
        List[Hole2D] | None,
        Field(
            description="A list of 2D holes in an element defined by closed polylines"
        ),
    ] = None
    zCoordinate: float


class PropertyDefinition(APIModel):
    name: str
    description: str
    type: PropertyDataType
    isEditable: bool
    defaultValue: BasicDefaultValue | ExpressionDefaultValue | None = None
    possibleEnumValues: Annotated[
        List[PossibleEnumValue] | None,
        Field(
            description="The possible enum values of the property when the property type is enumeration."
        ),
    ] = None
    availability: Annotated[
        List[ClassificationItemIdArrayItem],
        Field(
            description="The identifiers of classification items the new property is available for."
        ),
    ]
    group: Annotated[
        Group,
        Field(
            description="The property group defined by name or id. If both fields exists the id will be used."
        ),
    ]


class PropertyDefinitionArrayItem(APIModel):
    propertyDefinition: PropertyDefinition


class ElementsWithDetail(APIModel):
    elementId: ElementId
    details: Annotated[Details, Field(description="Details of an element.")]


class SetDetailsOfElementsParameters(APIModel):
    elementsWithDetails: Annotated[
        List[ElementsWithDetail], Field(description="The elements with parameters.")
    ]


class GetZoneBoundariesParameters(APIModel):
    zoneElementId: ElementId


class ZoneBoundary(APIModel):
    connectedElementId: Annotated[
        ElementId, Field(description="The unique identifier of the connected element.")
    ]
    isExternal: Annotated[
        bool, Field(description="True if the boundary is an external one.")
    ]
    neighbouringZoneElementId: Annotated[
        ElementId,
        Field(
            description="Returns the unique identifer of the other Zone the element connects to if the boundary is internal. Please note that this boundary does not represent the boundary of the element with the other Zone."
        ),
    ]
    area: Annotated[
        float, Field(description="The area of the polygon of the boundary.")
    ]
    polygonOutline: Annotated[
        List[Coordinate3D], Field(description="The outline polygon of the boundary.")
    ]


class GetZoneBoundariesResult(APIModel):
    zoneBoundaries: List[ZoneBoundary]


class Collision(APIModel):
    elementId1: ElementId
    elementId2: ElementId
    hasBodyCollision: bool
    hasClearenceCollision: bool


class GetCollisionsResult(APIModel):
    collisions: List[Collision]


class ElementsWithMoveVector(APIModel):
    elementId: ElementId
    moveVector: Annotated[MoveVector, Field(description="Move vector of a 3D point.")]
    copy_: Annotated[
        bool | None,
        Field(
            alias="copy",
            description="Optional parameter. If true, then a copy of the element will be moved. By default it's false.",
        ),
    ] = None


class MoveElementsParameters(APIModel):
    elementsWithMoveVectors: Annotated[
        List[ElementsWithMoveVector],
        Field(description="The elements with move vector pairs."),
    ]


class GetGDLParametersOfElementsResult(APIModel):
    gdlParametersOfElements: Annotated[
        List[GDLParameterList], Field(description="The GDL parameters of elements.")
    ]


class ElementsWithGDLParameter(APIModel):
    elementId: ElementId
    gdlParameters: Annotated[
        List[GDLParameterDetails], Field(description="The list of GDL parameters.")
    ]


class SetGDLParametersOfElementsParameters(APIModel):
    elementsWithGDLParameters: Annotated[
        List[ElementsWithGDLParameter],
        Field(description="The elements with GDL parameters dictionary pairs."),
    ]


class SetClassificationsOfElementsParameters(APIModel):
    elementClassifications: Annotated[
        List[ElementClassification],
        Field(description="A list of element classification identifiers."),
    ]


class ZonesDatum(APIModel):
    floorIndex: float | None = None
    name: Annotated[str, Field(description="Name of the zone.")]
    numberStr: Annotated[str, Field(description="Zone number.")]
    categoryAttributeId: Annotated[
        AttributeId | None,
        Field(description="The identifier of the zone category attribute."),
    ] = None
    stampPosition: Annotated[
        Coordinate2D | None,
        Field(description="Position of the origin of the zone stamp."),
    ] = None
    geometry: Annotated[
        AutomaticZoneGeometry | ManualZoneGeometry,
        Field(
            description="Defines the geometry of a zone. Used as input for creating zones."
        ),
    ]


class CreateZonesParameters(APIModel):
    zonesData: Annotated[
        List[ZonesDatum], Field(description="Array of data to create Zones.")
    ]


class FavoritesFromElement(APIModel):
    elementId: ElementId
    favorite: str


class CreateFavoritesFromElementsParameters(APIModel):
    favoritesFromElements: List[FavoritesFromElement]


class SetPropertyValuesOfElementsParameters(APIModel):
    elementPropertyValues: Annotated[
        List[ElementPropertyValue],
        Field(description="A list of element property values."),
    ]


class SetPropertyValuesOfAttributesParameters(APIModel):
    attributePropertyValues: Annotated[
        List[AttributePropertyValue],
        Field(description="A list of attribute property values."),
    ]


class CreatePropertyDefinitionsParameters(APIModel):
    propertyDefinitions: Annotated[
        List[PropertyDefinitionArrayItem],
        Field(description="The parameters of the new properties."),
    ]


class Attribute(APIModel):
    attributeId: AttributeId
    index: Annotated[float, Field(description="Index of the attribute.")]
    name: Annotated[str, Field(description="Name of the attribute.")]


class GetAttributesByTypeResult(APIModel):
    attributes: Annotated[List[Attribute], Field(description="Details of attributes.")]


class LayerDataArrayItem(APIModel):
    attributeId: Annotated[
        AttributeId | None,
        Field(
            description="Indentifier of the existing Layer to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    index: Annotated[
        str | None,
        Field(
            description="Index of the existing Layer to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="Name. If overwriteExisting is true, then the existing Layer with the given name will be overwritten."
        ),
    ]
    isHidden: Annotated[bool | None, Field(description="Hide/Show.")] = None
    isLocked: Annotated[bool | None, Field(description="Lock/Unlock.")] = None
    isWireframe: Annotated[
        bool | None, Field(description="Force the model to wireframe.")
    ] = None
    intersectionGroupNr: Annotated[
        int | None,
        Field(
            description="Intersection group. Elements on layers having the same group will be intersected."
        ),
    ] = None


class CreateLayersParameters(APIModel):
    layerDataArray: Annotated[
        List[LayerDataArrayItem],
        Field(description="Array of data to create new Layers."),
    ]
    overwriteExisting: Annotated[
        bool | None,
        Field(
            description="Overwrite the Layer if exists with the same name, or if index is given with the same index. The default is false."
        ),
    ] = None


class LayerCombinationDataArrayItem(APIModel):
    attributeId: Annotated[
        AttributeId | None,
        Field(
            description="Indentifier of the existing Layer Combination to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    index: Annotated[
        str | None,
        Field(
            description="Index of the existing Layer Combination to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="Name. If overwriteExisting is true, then the existing Layer Combination with the given name will be overwritten."
        ),
    ]
    layers: Annotated[
        List[LayersOfLayerCombinationItem],
        Field(description="List of Layers included in the Layer Combination."),
    ]


class CreateLayerCombinationsParameters(APIModel):
    layerCombinationDataArray: Annotated[
        List[LayerCombinationDataArrayItem],
        Field(description="Array of data to create new Layer Combinations."),
    ]
    overwriteExisting: Annotated[
        bool | None,
        Field(
            description="Overwrite the Layer Combination if exists with the same guid/index/name. The default is false."
        ),
    ] = None


class BuildingMaterialDataArrayItem(APIModel):
    attributeId: Annotated[
        AttributeId | None,
        Field(
            description="Indentifier of the existing Building Material to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    index: Annotated[
        str | None,
        Field(
            description="Index of the existing Building Material to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="Name. If overwriteExisting is true, then the existing Building Material with the given name will be overwritten."
        ),
    ]
    id: Annotated[str | None, Field(description="Identifier.")] = None
    manufacturer: Annotated[str | None, Field(description="Manufacturer.")] = None
    description: Annotated[str | None, Field(description="Decription.")] = None
    connPriority: Annotated[int | None, Field(description="Intersection priority.")] = (
        None
    )
    cutFillIndex: Annotated[int | None, Field(description="Index of the Cut Fill.")] = (
        None
    )
    cutFillPen: Annotated[int | None, Field(description="Cut Fill Foreground Pen.")] = (
        None
    )
    cutFillBackgroundPen: Annotated[
        int | None, Field(description="Cut Fill Background Pen.")
    ] = None
    cutSurfaceIndex: Annotated[
        int | None, Field(description="Index of the Cut Surface.")
    ] = None
    thermalConductivity: Annotated[
        float | None, Field(description="Thermal Conductivity.")
    ] = None
    density: Annotated[float | None, Field(description="Density.")] = None
    heatCapacity: Annotated[float | None, Field(description="Heat Capacity.")] = None
    embodiedEnergy: Annotated[float | None, Field(description="Embodied Energy.")] = (
        None
    )
    embodiedCarbon: Annotated[float | None, Field(description="Embodied Carbon.")] = (
        None
    )


class CreateBuildingMaterialsParameters(APIModel):
    buildingMaterialDataArray: Annotated[
        List[BuildingMaterialDataArrayItem],
        Field(description="Array of data to create new Building Materials."),
    ]
    overwriteExisting: Annotated[
        bool | None,
        Field(
            description="Overwrite the Building Material if exists with the same name, or if index is given with the same index. The default is false."
        ),
    ] = None


class GetLayerCombinationsResult(APIModel):
    layerCombinations: Annotated[
        List[LayerCombinationAttribute | ErrorItem],
        Field(description="A list of layer combinations."),
    ]


class Conflict(APIModel):
    elementId: ElementId
    user: User


class ReserveElementsResult(APIModel):
    executionResult: Annotated[
        SuccessfulExecutionResult | FailedExecutionResult,
        Field(description="The result of the execution."),
    ]
    conflicts: List[Conflict] | None = None


class Issue(APIModel):
    issueId: IssueId
    name: Annotated[str, Field(description="Issue name")]
    parentIssueId: IssueId
    creaTime: Annotated[int, Field(description="Issue creation time")]
    modiTime: Annotated[int, Field(description="Issue modification time")]
    tagText: Annotated[str, Field(description="Issue tag text - labels")]
    tagTextElementId: ElementId
    isTagTextElemVisible: Annotated[
        bool, Field(description="The visibility of the attached tag text element")
    ]


class GetIssuesResult(APIModel):
    issues: Annotated[List[Issue], Field(description="A list of existing issues.")]


class ElementIdArrayItem(APIModel):
    elementId: ElementId


class AttributeIdArrayItem(APIModel):
    attributeId: AttributeId


class CurtainWallPanelDetails(APIModel):
    polygonCoordinates: Annotated[
        List[Coordinate3D],
        Field(description="The 3D coordinates of the panel polygon.", min_length=3),
    ]
    isHidden: Annotated[
        bool,
        Field(
            description="Indicates if the panel is hidden (deleted panels remain in the database)."
        ),
    ]
    segmentIndex: Annotated[
        float,
        Field(
            description="The index of the curtain wall segment to which this panel belongs."
        ),
    ]
    className: str
    frames: Annotated[
        List[ElementIdArrayItem],
        Field(description="The surrounding frames.", min_length=3),
    ]


class GetElementsByTypeParameters(APIModel):
    elementType: ElementType
    filters: Annotated[List[ElementFilter] | None, Field(min_length=1)] = None
    databases: Annotated[
        List[DatabaseIdArrayItem] | None,
        Field(description="A list of Archicad databases."),
    ] = None


class GetAllElementsParameters(APIModel):
    filters: Annotated[List[ElementFilter] | None, Field(min_length=1)] = None
    databases: Annotated[
        List[DatabaseIdArrayItem] | None,
        Field(description="A list of Archicad databases."),
    ] = None


class DetailsOfElement(APIModel):
    type: ElementType
    id: str
    floorIndex: float
    layerIndex: float
    drawIndex: float
    details: Annotated[
        WallDetails
        | BeamDetails
        | SlabDetails
        | ColumnDetails
        | DetailWorksheetDetails
        | LibPartBasedElementDetails
        | PolylineDetails
        | ZoneDetails
        | CurtainWallDetails
        | CurtainWallSegmentDetails
        | CurtainWallPanelDetails
        | CurtainWallFrameDetails
        | MeshDetails
        | NotYetSupportedElementTypeDetails,
        Field(
            description="Represents the complete type-specific details of an element. Used as output from GET requests"
        ),
    ]


class GetDetailsOfElementsResult(APIModel):
    detailsOfElements: List[DetailsOfElement]


class Skin(APIModel):
    type: Annotated[str, Field(description="Skin type (Core, Finish, or Other)")]
    buildingMaterialId: AttributeIdArrayItem
    framePen: Annotated[int, Field(description="Skin frame pen index.")]
    thickness: Annotated[float, Field(description="Skin thickness (in meters).")]


class Separator(APIModel):
    lineTypeId: AttributeIdArrayItem
    linePen: Annotated[int, Field(description="Separator line pen index.")]


class CompositeDataArrayItem(APIModel):
    attributeId: Annotated[
        AttributeId | None,
        Field(
            description="Indentifier of the existing Composite to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    index: Annotated[
        str | None,
        Field(
            description="Index of the existing Composite to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="Name. If overwriteExisting is true, then the existing Composite with the given name will be overwritten."
        ),
    ]
    useWith: Annotated[
        List[str] | None,
        Field(description="Array of types the composite can used with."),
    ] = None
    skins: Annotated[List[Skin], Field(description="Array of skin data.")]
    separators: Annotated[
        List[Separator],
        Field(
            description="Array of skin separator data. The number of items must be the number of skins plus one."
        ),
    ]


class CreateCompositesParameters(APIModel):
    compositeDataArray: Annotated[
        List[CompositeDataArrayItem],
        Field(description="Array of data to create Composites."),
    ]
    overwriteExisting: Annotated[
        bool | None,
        Field(
            description="Overwrite the Composite if exists with the same name, or if index is given with the same index. The default is false."
        ),
    ] = None


class SurfaceDataArrayItem(APIModel):
    attributeId: Annotated[
        AttributeId | None,
        Field(
            description="Indentifier of the existing Surface to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    index: Annotated[
        str | None,
        Field(
            description="Index of the existing surface to overwrite, ignored if overwriteExisting is false."
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="Name. If overwriteExisting is true, then the existing surface with the given name will be overwritten."
        ),
    ]
    materialType: SurfaceType
    ambientReflection: Annotated[
        float, Field(description="Ambient percentage [0..100].")
    ]
    diffuseReflection: Annotated[
        float, Field(description="Diffuse percentage [0..100].")
    ]
    specularReflection: Annotated[
        float, Field(description="Specular percentage [0..100].")
    ]
    transparency: Annotated[
        float, Field(description="Transparency percentage [0..100].")
    ]
    shine: Annotated[
        float, Field(description="The shininess factor multiplied by 100 [0..10000].")
    ]
    transparencyAttenuation: Annotated[
        float,
        Field(description="Transparency attenuation multiplied by 100 [0..10000]."),
    ]
    emissionAttenuation: Annotated[
        float, Field(description="Emission attenuation multiplied by 100 [0..10000].")
    ]
    surfaceColor: ColorRGB
    specularColor: ColorRGB
    emissionColor: ColorRGB
    fillId: AttributeIdArrayItem | None = None
    texture: Texture | None = None


class CreateSurfacesParameters(APIModel):
    surfaceDataArray: Annotated[
        List[SurfaceDataArrayItem],
        Field(description="Array of data to create new surfaces."),
    ]
    overwriteExisting: Annotated[
        bool | None,
        Field(
            description="Overwrite the Surface if exists with the same name, or if index is given with the same index. The default is false."
        ),
    ] = None


class GetDatabaseIdFromNavigatorItemIdParameters(APIModel):
    navigatorItemIds: Annotated[
        List[NavigatorItemIdArrayItem],
        Field(description="A list of navigator item identifiers."),
    ]


class GetDatabaseIdFromNavigatorItemIdResult(APIModel):
    databases: Annotated[
        List[DatabaseIdArrayItem], Field(description="A list of Archicad databases.")
    ]


class GetViewSettingsParameters(APIModel):
    navigatorItemIds: Annotated[
        List[NavigatorItemIdArrayItem],
        Field(description="A list of navigator item identifiers."),
    ]


class GetView2DTransformationsParameters(APIModel):
    databases: Annotated[
        List[DatabaseIdArrayItem] | None,
        Field(description="A list of Archicad databases."),
    ] = None


class GetCurrentRevisionChangesOfLayoutsParameters(APIModel):
    layoutDatabaseIds: Annotated[
        List[DatabaseIdArrayItem], Field(description="A list of Archicad databases.")
    ]


class GetSelectedElementsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetElementsByTypeResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    executionResultForDatabases: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult] | None,
        Field(description="A list of execution results."),
    ] = None


class GetAllElementsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    executionResultForDatabases: Annotated[
        List[SuccessfulExecutionResult | FailedExecutionResult] | None,
        Field(description="A list of execution results."),
    ] = None


class ChangeSelectionOfElementsParameters(APIModel):
    addElementsToSelection: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    removeElementsFromSelection: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None


class FilterElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    filters: Annotated[List[ElementFilter] | None, Field(min_length=1)] = None


class FilterElementsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetDetailsOfElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class Get3DBoundingBoxesParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetSubelementsOfHierarchicalElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class Subelement(APIModel):
    cWallSegments: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    cWallFrames: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    cWallPanels: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    cWallJunctions: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    cWallAccessories: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    stairRisers: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    stairTreads: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    stairStructures: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingNodes: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingSegments: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingPosts: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingRailEnds: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingRailConnections: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingHandrailEnds: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingHandrailConnections: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingToprailEnds: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingToprailConnections: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingRails: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingToprails: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingHandrails: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingPatterns: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingInnerPosts: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingPanels: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingBalusterSets: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    railingBalusters: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    beamSegments: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None
    columnSegments: Annotated[
        List[ElementIdArrayItem] | None, Field(description="A list of elements.")
    ] = None


class GetSubelementsOfHierarchicalElementsResult(APIModel):
    subelements: List[Subelement]


class GetConnectedElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    connectedElementType: ElementType


class ConnectedElement(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetConnectedElementsResult(APIModel):
    connectedElements: List[ConnectedElement]


class GetCollisionsParameters(APIModel):
    elementsGroup1: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    elementsGroup2: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    settings: Settings | None = None


class HighlightElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    highlightedColors: Annotated[
        List[HighlightedColor],
        Field(description="A list of colors to highlight elements."),
    ]
    wireframe3D: Annotated[
        bool | None,
        Field(
            description="Optional parameter. Switch non highlighted elements in the 3D window to wireframe."
        ),
    ] = None
    nonHighlightedColor: Annotated[
        List[int] | None,
        Field(
            description="Optional parameter. Color of the non highlighted elements as an [r, g, b, a] array. Each component must be in the 0-255 range.",
            max_length=4,
            min_length=4,
        ),
    ] = None


class DeleteElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetGDLParametersOfElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetClassificationsOfElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    classificationSystemIds: Annotated[
        List[ClassificationSystemIdArrayItem],
        Field(description="A list of classification system identifiers."),
    ]


class CreateColumnsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class CreateSlabsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class CreateZonesResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class CreatePolylinesResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class CreateObjectsResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class CreateMeshesResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetPropertyValuesOfElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    properties: Annotated[
        List[PropertyIdArrayItem], Field(description="A list of property identifiers.")
    ]


class GetPropertyValuesOfAttributesParameters(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]
    properties: Annotated[
        List[PropertyIdArrayItem], Field(description="A list of property identifiers.")
    ]


class CreateLayersResult(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class CreateLayerCombinationsResult(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class CreateBuildingMaterialsResult(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class CreateCompositesResult(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class CreateSurfacesResult(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class GetBuildingMaterialPhysicalPropertiesParameters(APIModel):
    attributeIds: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class GetLayerCombinationsParameters(APIModel):
    attributes: Annotated[
        List[AttributeIdArrayItem], Field(description="A list of attributes.")
    ]


class ReserveElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class ReleaseElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class UpdateDrawingsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class AttachElementsToIssueParameters(APIModel):
    issueId: IssueId
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]
    type: IssueElementType


class DetachElementsFromIssueParameters(APIModel):
    issueId: IssueId
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetElementsAttachedToIssueResult(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class GetRevisionChangesOfElementsParameters(APIModel):
    elements: Annotated[
        List[ElementIdArrayItem], Field(description="A list of elements.")
    ]


class Hotlink(APIModel):
    location: Annotated[str, Field(description="The path of the hotlink file.")]
    children: Annotated[
        List[Hotlink] | None,
        Field(description="The children of the hotlink node if it has any."),
    ] = None


class GetHotlinksResult(APIModel):
    hotlinks: Annotated[List[Hotlink], Field(description="A list of hotlink nodes.")]
