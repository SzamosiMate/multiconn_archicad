import re
from code_generation.tapir.paths import paths

def main():
    """
    Performs a final, surgical cleaning of the generated TypedDict models.
    This script addresses known artifacts from the datamodel-codegen process
    to produce a clean, valid, and usable TypedDict models file for static analysis.
    """
    print(f"--- Starting definitive cleaning of {paths.RAW_TYPED_DICTS} ---")

    try:
        content = paths.RAW_TYPED_DICTS.read_text(encoding="utf-8")
    except FileNotFoundError:
        print(f"Error: {paths.RAW_TYPED_DICTS} not found. Please generate it first.")
        return

    # The order of these operations is critical for success.
    print("Step 1: Reordering forward-referencing TypeAliases...")
    content = surgically_fix_copy_keyword(content)
    print("Step 2: Reordering forward-referencing TypeAliases...")
    content = fix_forward_reference_aliases(content)
    print("Step 3: Assembling and formatting the final file...")
    content = assemble_final_file(content)

    paths.CLEANED_TYPED_DICTS.write_text(content, encoding="utf-8")
    print(f"âœ… Successfully created final, clean TypedDict models at: {paths.CLEANED_TYPED_DICTS}")


### Cleaning Logic Functions (in execution order) ###

def surgically_fix_copy_keyword(content: str) -> str:
    field_to_fix = "copy_: NotRequired[bool]"
    correct_field = "copy: NotRequired[bool]"
    if field_to_fix in content:
        content = content.replace(field_to_fix, correct_field)
        print(f"    - Corrected '{field_to_fix}' -> '{correct_field}'")
    return content


def fix_forward_reference_aliases(content: str) -> str:
    """
    Finds patterns like `Alias = List[Class]` defined before `class Class(TypedDict)`
    and swaps them to ensure correct definition order for static analysis.
    """
    # This regex finds the problematic alias and class definition blocks.
    # It uses a backreference `(?P=class_name)` to ensure it matches the correct class.
    pattern = re.compile(
        r"^(?P<alias_block>(?P<alias_name>\w+)\s*=\s*List\[(?P<class_name>\w+)\])\n+(?P<class_block>class\s+(?P=class_name)\(TypedDict\):(?:\n(?:    .*))+)",
        re.MULTILINE
    )

    # The replacement function swaps the captured groups.
    def replacer(match):
        print(f"    - Reordered '{match.group('alias_name')}' to be after '{match.group('class_name')}'.")
        return f"{match.group('class_block')}\n\n\n{match.group('alias_block')}"

    # Substitute all occurrences found in the content.
    content, num_replacements = pattern.subn(replacer, content)

    if num_replacements == 0:
        print("    - No forward-reference aliases needed reordering.")

    return content


def assemble_final_file(content: str) -> str:
    """Adds a standard header, imports, and performs final formatting."""
    content = content.replace("TapirMasterModels = Any", "")

    body_lines = [
        line for line in content.splitlines()
        if line.strip()
        and not line.strip().startswith(("#", "from __future__", "from typing"))
    ]

    header = [
        "from __future__ import annotations",
        "",
        "from typing import Any, List, Literal, TypedDict",
        "",
        "from typing_extensions import NotRequired",
        "",
        "### This file is automatically generated and surgically cleaned. Do not edit directly. ###",
    ]

    final_content = "\n".join(header + [""] + body_lines)

    # Standardize spacing between definitions for readability.
    final_content = re.sub(r'\n(class |[A-Z]\w+\s*=)', r'\n\n\n\1', final_content)
    # Clean up excessive newlines that might be introduced during processing.
    final_content = re.sub(r'\n{4,}', '\n\n\n', final_content)

    return final_content.strip() + "\n"


if __name__ == "__main__":
    main()