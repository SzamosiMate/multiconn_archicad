# code_generation/official/07_generate_model_tests.py

import json
import copy
import re
from typing import Any, Dict, Set, Union

from code_generation.official.paths import official_paths

# Known schemas that are too complex or recursive for hypothesis to handle efficiently.
SCHEMAS_TO_PATCH = {
    "GetNavigatorItemTreeResult",
    "GetAllClassificationsInSystemResult",
    "GetAttributeFolderStructureResult",
    "GetPropertyValuesOfElementComponentsResult",
}


def remove_uuid_patterns_recursively(data: Union[Dict, list]) -> None:
    """
    Recursively traverses a schema and removes the 'pattern' key from any
    object that has 'type': 'string' and 'format': 'uuid'. This resolves
    a conflict in hypothesis-jsonschema's strategy selection.
    """
    if isinstance(data, dict):
        for value in data.values():
            remove_uuid_patterns_recursively(value)
    elif isinstance(data, list):
        for item in data:
            remove_uuid_patterns_recursively(item)


def collect_dependencies_recursively(
    name: str, all_definitions: Dict[str, Any], collected_defs: Dict[str, Any], processed: Set[str]
):
    """Recursively collects all schemas referenced by a given schema name."""
    if name in processed:
        return
    processed.add(name)
    if name not in all_definitions:
        print(f"   ‚ö†Ô∏è Warning: Definition for '{name}' not found in master schema.")
        return
    definition = all_definitions[name]
    collected_defs[name] = definition
    content_str = json.dumps(definition)
    dependencies = re.findall(r'"#/\$defs/(\w+)"', content_str)
    for dep_name in set(dependencies):
        collect_dependencies_recursively(dep_name, all_definitions, collected_defs, processed)


def patch_schema_definitions(definitions: dict, model_name_to_test: str) -> dict:
    """Applies specific patches to fix recursion or performance issues."""
    patched_defs = copy.deepcopy(definitions)

    if model_name_to_test == "GetNavigatorItemTreeResult":
        if "NavigatorItem" in patched_defs and "properties" in patched_defs["NavigatorItem"]:
            patched_defs["NavigatorItem"]["properties"].pop("children", None)
            print(f"    - Applied patch to 'NavigatorItem' for {model_name_to_test} test (removed recursion).")

    if model_name_to_test == "GetAllClassificationsInSystemResult":
        if "ClassificationItemInTree" in patched_defs and "properties" in patched_defs["ClassificationItemInTree"]:
            patched_defs["ClassificationItemInTree"]["properties"].pop("children", None)
            print(f"    - Applied patch to 'ClassificationItemInTree' for {model_name_to_test} test (removed recursion).")

    if model_name_to_test == "GetAttributeFolderStructureResult":
        if "AttributeFolderStructure" in patched_defs and "properties" in patched_defs["AttributeFolderStructure"]:
            patched_defs["AttributeFolderStructure"]["properties"].pop("subfolders", None)
            print(f"    - Applied patch to 'AttributeFolderStructure' for {model_name_to_test} test (removed recursion).")

    if model_name_to_test == "GetPropertyValuesOfElementComponentsResult":
        if "properties" in patched_defs[model_name_to_test]:
            patched_defs[model_name_to_test]["properties"]["propertyValuesForElementComponents"]["maxItems"] = 1
            print(f"    - Applied patch to '{model_name_to_test}' schema (limited list size).")

    return patched_defs


def main():
    """Generates a pytest file with property-based tests for Pydantic models."""
    print("--- Starting Official API Test File Generation ---")

    try:
        with open(official_paths.MASTER_SCHEMA_OUTPUT, "r", encoding="utf-8") as f:
            master_schema = json.load(f)
        with open(official_paths.COMMAND_MODELS_NAMES_OUTPUT, "r", encoding="utf-8") as f:
            command_model_names = json.load(f)
    except FileNotFoundError as e:
        print(f"‚ùå Error: A required file was not found. Please run the full pipeline. ({e})")
        return

    output_path = official_paths.GENERATED_TESTS_OUTPUT
    all_definitions_master = master_schema.get("$defs", {})

    print("üîß Applying global patch: Removing redundant 'pattern' from 'uuid' formats...")
    remove_uuid_patterns_recursively(all_definitions_master)
    print("‚úÖ UUID pattern patch applied.")

    file_header = f"""
# This file is automatically generated by the pipeline. Do not edit directly.

import pytest
import json
from hypothesis import given, settings, HealthCheck
from hypothesis_jsonschema import from_schema
from pydantic import ValidationError

# Note: Importing from the correct final model locations
from multiconn_archicad.models.official.types import *
from multiconn_archicad.models.official.commands import *

# Increase deadline and disable the 'too_slow' health check for complex models.
settings.register_profile("ci", deadline=1000, suppress_health_check=[HealthCheck.too_slow])
settings.load_profile("ci")
"""

    test_functions = []
    print("\n‚öôÔ∏è  Generating tests with minimal, self-contained schemas...")
    for model_name in sorted(command_model_names):
        source_definitions = all_definitions_master
        if model_name in SCHEMAS_TO_PATCH:
            print(f"   - Applying specific patch for model: {model_name}")
            source_definitions = patch_schema_definitions(all_definitions_master, model_name)

        minimal_definitions = {}
        collect_dependencies_recursively(model_name, source_definitions, minimal_definitions, set())

        temp_schema_for_test = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "$defs": minimal_definitions,
            "$ref": f"#/$defs/{model_name}",
        }
        schema_as_string = repr(json.dumps(temp_schema_for_test))

        test_function = f"""

@given(data=from_schema(json.loads({schema_as_string})))
def test_instantiate_{model_name}(data: dict):
    try:
        {model_name}.model_validate(data)
    except Exception as e:
        pytest.fail(f"Failed to instantiate {model_name} with data: {{repr(data)}}\\nError: {{e}}")

"""
        test_functions.append(test_function)

    final_content = file_header + "".join(test_functions)
    output_path.write_text(final_content, encoding="utf-8")

    print(f"\n‚úÖ Successfully generated {len(test_functions)} tests.")
    print(f"   Applied patches to {len(SCHEMAS_TO_PATCH)} test schemas.")
    print(f"   Test file created at: {output_path}")


if __name__ == "__main__":
    main()